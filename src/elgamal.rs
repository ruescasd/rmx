use curve25519_dalek::ristretto::{RistrettoPoint, CompressedRistretto};
use curve25519_dalek::scalar::Scalar;
use curve25519_dalek::constants::{RISTRETTO_BASEPOINT_POINT, BASEPOINT_ORDER};
use rand_core::{CryptoRng, OsRng, RngCore};
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Copy, Clone)]
pub struct Ciphertext {
    pub a: RistrettoPoint,
    pub b: RistrettoPoint
}

pub struct PublicKey(pub RistrettoPoint);

impl PublicKey {
    pub fn encrypt<T: RngCore + CryptoRng>(&self, plaintext: RistrettoPoint, csprng: &mut T) -> Ciphertext {
        let randomness = Scalar::random(csprng);
        Ciphertext {
            a: plaintext + (self.0 * randomness),
            b: RISTRETTO_BASEPOINT_POINT * randomness
        }
    }
}

pub struct PrivateKey(Scalar);

impl PrivateKey {
    pub fn random<T: RngCore + CryptoRng>(csprng: &mut T) -> Self {
        return PrivateKey(Scalar::random(csprng));
    }
    pub fn public_key(&self) -> PublicKey {
        return PublicKey(RISTRETTO_BASEPOINT_POINT * self.0);
    }
    pub fn decrypt(&self, c: Ciphertext) -> RistrettoPoint {
        c.a - (c.b * self.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_encryption() {
        let mut csprng = OsRng;
        let sk = PrivateKey::random(&mut csprng);
        
        let pk = sk.public_key();
        let text = "this has to be exactly 32 bytes!";
        // let text = "phis has to be exactly 32 bytes!";
        println!("{:?}", text.as_bytes().len());

        let plaintext = CompressedRistretto::from_slice(text.as_bytes());    
        
        let c: Ciphertext = pk.encrypt(plaintext.decompress().unwrap(), &mut csprng);
        let d: RistrettoPoint = sk.decrypt(c);
        
        let recovered = String::from_utf8(d.compress().as_bytes().to_vec());
        assert_eq!(text, recovered.unwrap());

        // data generated by ristretto255.js
        /*
        let skb: [u8;32] = [
            157, 127, 250, 139, 158,  32, 121,
            69, 255, 102, 151, 206, 199, 225,
            118, 203, 168, 220, 193, 198, 226,
            74, 167,  77, 209,  52,  70, 173,
            180, 176, 153,   9
        ];
        
        let a: [u8;32] = [
            72,  60, 143,  64,  93, 212,  68, 113,
            253,   8, 206,  72, 111,  39,  75, 156,
            189,  63, 176, 223,  97, 221,  58, 132,
             11, 209,  70, 149,  90,  73, 141,  70
        ];
          
        let b: [u8;32] = [
            182,  67, 141,   0, 95, 109,  54, 179,
            179, 226,  25, 148, 80, 160, 171,  82,
            173, 129,  68,  24, 64, 236,  36, 144,
            183, 193,  36, 180, 82, 206,  98,  41
        ];

        let sk_ = PrivateKey(Scalar::from_bytes_mod_order(skb));
        let c_ = Ciphertext {
            a: CompressedRistretto(a).decompress().unwrap(),
            b: CompressedRistretto(b).decompress().unwrap()
        };
        let d_: RistrettoPoint = sk_.decrypt(c_);
        let recovered_ = String::from_utf8(d_.compress().as_bytes().to_vec());
        assert_eq!(text, recovered_.unwrap());
        */
    }
}